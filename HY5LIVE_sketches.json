{"app":"HY5LIVE","time":1743114739,"files":[{"name":"incr2","code":"// register WebMIDI\nnavigator.requestMIDIAccess()\n    .then(onMIDISuccess, onMIDIFailure);\nfunction onMIDISuccess(midiAccess) {\n    console.log(midiAccess);\n    var inputs = midiAccess.inputs;\n    var outputs = midiAccess.outputs;\n    for (var input of midiAccess.inputs.values()){\n        input.onmidimessage = getMIDIMessage;\n    }\n}\nfunction onMIDIFailure() {\n    console.log('Could not access your MIDI devices.');\n}\n//create an array to hold our cc values and init to a normalized value\nvar cc=Array(128).fill(0.5)\ngetMIDIMessage = function(midiMessage) {\n    var arr = midiMessage.data    \n    var index = arr[1]\n    //console.log('Midi received on cc#' + index + ' value:' + arr[2])    // uncomment to monitor incoming Midi\n    var val = (arr[2]+1)/128.0  // normalize CC values to 0.0 - 1.0\n    cc[index]=val\n}\n\n\n///////// SHAPE GRID\n\nfunction sphereSize(factor=1, speed=1){\n //return height/3+(frameCount%(height/6))\n return (Math.sin(frameCount*(speed/100))*100 +200)*factor\n}\n\nfunction sphereGrid(sphereSize=100, gridX=5, gridY=5, gridZ=5, spacing=200){\n  let offset = (gridX - 1) * spacing / 2\n  for (let x = 0; x < gridX; x++) {\n    for (let y = 0; y < gridY; y++) {\n      for (let z = 0; z < gridZ; z++) {\n        push();\n        // Positionner chaque sphère\n        translate(\n          x * spacing - offset,\n          y * spacing - offset,\n          z * spacing - offset\n        );\n        // Couleur basée sur la position\n/*        let r = map(x, 0, gridX - 1, 50, 255)\n        let g = map(y, 0, gridY - 1, 50, 255)\n        let b = map(z, 0, gridZ - 1, 50, 255)\n        fill(r, g, b)*/\n        texture(H.get())\n        sphere(sphereSize, 32)\n        pop()\n      }\n    }\n  }\n}\n\n///////////////////////////////\n\n\n////////// CREATURES\n\nclass Segment {\n  constructor(x, y, r, c) {\n    this.x = x;\n    this.y = y;\n    this.r = r; \n    this.angle = 0;\n    this.face = false;\n    this.c = c;\n  }\n  \n  update(x, y, speed, distTarget) {\n    let dx = x - this.x;\n    let dy = y - this.y;\n    this.angle = atan2(dy, dx);\n\n    let distBtw = dist(x, y, this.x, this.y);\n    if (distBtw > distTarget) {\n      let distTravel = distBtw - distTarget;\n      this.x += speed * distTravel * cos(this.angle);\n      this.y += speed * distTravel * sin(this.angle);\n    }\n\n  }\n  \n  display() {\n    stroke(255);\n    push();\n    translate(this.x, this.y);\n    rotate(this.angle);\n    \n    if (this.face) {\n      fill(this.c); \n    } else {\n      noFill();\n    }\n    ellipse(0, 0, this.r*2, this.r*2);\n    // line(0, 0, this.r, 0);\n    \n    if (this.face) {\n      this.drawFace();\n    }\n    \n    pop();\n  }\n  \n  drawFace() {\n    rotate(HALF_PI);\n    // Eyes\n    noStroke();\n    fill(0);\n    let eyeOffsetX = this.r * 0.3;\n    let eyeOffsetY = -this.r * 0.1;\n    ellipse(-eyeOffsetX, eyeOffsetY, 4, 4);\n    ellipse(eyeOffsetX, eyeOffsetY, 4, 4);\n    \n    // Nose \n    ellipse(0, 0, 3, 3);\n    \n    // Mouth\n    noFill();\n    stroke(0);\n    let x = 0;\n    let y = this.r * 0.15; \n    let w = this.r * 0.6;\n    let h = this.r * 0.4; \n    arc(x, y, w, h, 0, PI);\n  }\n}\n\nclass Creature {\n  constructor(r0, num, c) {\n    this.segments = []; \n    this.num = num;\n    this.r0 = r0; \n    this.c = c;\n    \n    for (let i=0; i<this.num; i++) {\n      let x = width/2 - i*this.r0;\n      let y = height/2;\n      let r = this.r0 * 1.5 - (this.r0 / (this.num - 1)) * i\n      this.segments[i] = new Segment(x, y, r, this.c);\n    }\n\n\n    this.target = createVector(random(width), random(height));\n    this.velocity = p5.Vector.random2D().mult(random(1, 3));\n    \n    this.head = this.segments[0];\n    this.head.face = true;\n    this.tail = this.segments[this.segments.length-1];\n    \n  }\n  \n  update() {\n    this.setDirection();\n\n    // Head \n    this.head.update(this.target.x, this.target.y, 0.1, 10);\n\n    // Body\n    for (let i=1; i<this.num; i++) {\n      let prev = this.segments[i - 1];\n      let curr = this.segments[i];\n      let distTarget = (prev.r + curr.r)/2;\n      this.segments[i].update(prev.x, prev.y, 1, distTarget);\n    }  \n    \n  }\n  \n  setDirection() {\n    this.target.add(this.velocity);\n  \n    if (this.target.x > width) {\n      this.velocity.x *= -1;\n      this.target.x = width;\n    } else if (this.target.x < 0) {\n      this.velocity.x *= -1;\n      this.target.x = 0;\n    }\n\n    if (this.target.y > height) {\n      this.velocity.y *= -1;\n      this.target.y = height;\n    } else if (this.target.y < 0) {\n      this.velocity.y *= -1;\n      this.target.y = 0;\n    }\n\n    noStroke();\n    // fill(0);\n    // ellipse(this.target.x, this.target.y, 5, 5);\n  }\n  \n  display() {\n    this.displayOutline();\n    this.displayCircles();\n    this.head.display();\n  }\n  \n  displayCircles() {\n    for (let i=0; i<this.num; i++) {\n      this.segments[i].display();\n    }\n  }\n  \n  displayOutline() {\n    fill(this.c);\n\n    beginShape();\n    for (let i = HALF_PI; i> -HALF_PI; i-=PI/20) {\n      let x = this.head.x + this.head.r * cos(this.head.angle + i);\n      let y = this.head.y + this.head.r * sin(this.head.angle + i);\n      vertex(x, y);\n    }\n    \n    for (let i=0; i<this.segments.length; i++) {\n      let seg = this.segments[i];\n      let x = seg.x + seg.r * cos(seg.angle - HALF_PI);\n      let y = seg.y + seg.r * sin(seg.angle - HALF_PI);\n      vertex(x, y);\n    }\n    \n    for (let i = 3*HALF_PI; i>HALF_PI; i-=PI/20) {\n      let x = this.tail.x + this.tail.r * cos(this.tail.angle + i);\n      let y = this.tail.y + this.tail.r * sin(this.tail.angle + i);\n      vertex(x, y);\n    }\n    \n    for (let i=this.segments.length-1; i>=0; i--) {\n      let seg = this.segments[i];\n      let x = seg.x + seg.r * cos(seg.angle + HALF_PI);\n      let y = seg.y + seg.r * sin(seg.angle + HALF_PI);\n      vertex(x, y);\n    }\n    endShape(CLOSE);\n  }\n}\n\nclass Creatures{\n\tconstructor(num=30, minSize=5, maxSize=20){\n\t\tthis.numCreatures = num;\n\t\tthis.colorPalette = [color(254, 166, 161), color(0, 133, 212), color(252, 197, 3), color(252, 71, 1), color(1, 162, 72)];\n\t\tthis.creatures = [];\n\t\tthis.minSize = minSize;\n\t\tthis.maxSize = maxSize;\n\t}\n\tsetup(){\n\t  for (let i=0; i<this.numCreatures; i++) {\n\t    let r0 = floor(random(2, 42)); \n\t    let numCircles = floor(random(this.minSize, this.maxSize));\n\t    this.creatures.push(new Creature(r0, numCircles, this.colorPalette[i % this.colorPalette.length]));\n\t  }\n\t}\n\tdraw(){\n\t  for (let i=0; i<this.numCreatures; i++) {\n\t    this.creatures[i].update();\n\t    this.creatures[i].display();\n\t  }\n\t}\n}\n\n//////////////////////////////\n\n\n\nH.toggle(1)\nH.pd(.5)\n\nfunction grad1() {\n return [.2,.999].smooth()\n}\n\n\n//noize(30, 2).thresh(()=>sin(time)).mult(osc(40, 1, [.5,2].smooth()).colorama(.1).modulate(noize())).out()\n//noize(3, 2).modulate(noize(), window.grad1()).out()\n\ns0.initVideo(\"https://media.giphy.com/media/AS9LIFttYzkc0/giphy.mp4\")\ns1.initCam()\nsrc(s1).modulate(noize(3), 0).out()\n//solid(()=>cc[56]).out()\n\n\nspeed=10\nlet lescreatures;\n\nfunction setup() {\n lescreatures = new Creatures(50);\n createCanvas(windowWidth, windowHeight, WEBGL)\n P5.zIndex(1)\n normalMaterial()\n lescreatures.setup()\n}\n\n\n\n\nfunction draw() {\n clear()\n background(0)\n orbitControl(1)\n //rotateY(radians(frameCount/1))\n\n noStroke()\n //texture(H.get())\n \n //sphere(sphereSize(), 64)\n sphereGrid(sphereSize(1, 3), 2, 2, 1, spacing=700)\n \n lescreatures.draw()\n}\n\n\nvar H2 = HY5.hydra('h2', 'synth')\nH2.pixelDensity(2)\nH2.zIndex(2)\nsynth.s0.initP5()\nsynth.s1.initCam()\n\nsynth.src(synth.s0)\n    //.add(src(synth.s1))\n\t//.modulateScale(synth.src(synth.o0).scale(1.01), [0,2].fast(0.1).smooth())\n\t//.thresh([.2,.7].smooth())\n\t//.modulate(osc(8,.2),.1)\n\t//.brightness(.2)\n\t//.contrast(3)\n\t.out()\n"},{"name":"incr","code":"// register WebMIDI\nnavigator.requestMIDIAccess()\n    .then(onMIDISuccess, onMIDIFailure);\n\nfunction onMIDISuccess(midiAccess) {\n    console.log(midiAccess);\n    var inputs = midiAccess.inputs;\n    var outputs = midiAccess.outputs;\n    for (var input of midiAccess.inputs.values()){\n        input.onmidimessage = getMIDIMessage;\n    }\n}\n\nfunction onMIDIFailure() {\n    console.log('Could not access your MIDI devices.');\n}\n\n//create an array to hold our cc values and init to a normalized value\nvar cc=Array(128).fill(0.5)\n\ngetMIDIMessage = function(midiMessage) {\n    var arr = midiMessage.data    \n    var index = arr[1]\n    //console.log('Midi received on cc#' + index + ' value:' + arr[2])    // uncomment to monitor incoming Midi\n    var val = (arr[2]+1)/128.0  // normalize CC values to 0.0 - 1.0\n    cc[index]=val\n}\n\n// code hydra [+/-] p5 or drag + drop .js hydra/p5 file(s) here\n// code hydra [+/-] p5 or drag + drop .js hydra/p5 file(s) here\n//spheregrid1\nH.toggle(0) // hide hydra\nH.pd(.5)\n\nfunction grad1() {\n //return [.2,.999].smooth()\n return 3\n}\n\n\n//noize(30, 2).thresh(()=>sin(time)).mult(osc(40, 1, [.5,2].smooth()).colorama(.1).modulate(noize())).out()\n//noize(3, 2).modulate(noize(), window.grad1()).out()\n\ns0.initVideo(\"https://media.giphy.com/media/AS9LIFttYzkc0/giphy.mp4\")\ns1.initCam()\nsrc(s1).modulate(noize(3), 0).out()\n//solid(()=>cc[56]).out()\n\n\nspeed=10\n\nfunction setup() {\n createCanvas(windowWidth, windowHeight, WEBGL)\n P5.zIndex(1)\n normalMaterial()\n}\n\n\n\nfunction sphereSize(factor=1, speed=1){\n //return height/3+(frameCount%(height/6))\n return (Math.sin(frameCount*(speed/100))*100 +200)*factor\n}\n\nfunction sphereGrid(sphereSize=100, gridX=5, gridY=5, gridZ=5, spacing=200){\n  let offset = (gridX - 1) * spacing / 2\n  for (let x = 0; x < gridX; x++) {\n    for (let y = 0; y < gridY; y++) {\n      for (let z = 0; z < gridZ; z++) {\n        push();\n        // Positionner chaque sphère\n        translate(\n          x * spacing - offset,\n          y * spacing - offset,\n          z * spacing - offset\n        );\n        // Couleur basée sur la position\n/*        let r = map(x, 0, gridX - 1, 50, 255)\n        let g = map(y, 0, gridY - 1, 50, 255)\n        let b = map(z, 0, gridZ - 1, 50, 255)\n        fill(r, g, b)*/\n        texture(H.get())\n        sphere(sphereSize, 32)\n        pop()\n      }\n    }\n  }\n}\n\nfunction draw() {\n clear()\n background(0)\n orbitControl(0)\n rotateY(radians(frameCount/1))\n\n noStroke()\n texture(H.get())\n \n //sphere(sphereSize(), 64)\n sphereGrid(sphereSize(.5, 3), 3, 3, 3, spacing=400)\n}\n\n\nvar H2 = HY5.hydra('h2', 'synth')\nH2.pixelDensity(2)\nH2.zIndex(2)\nsynth.s0.initP5()\nsynth.s1.initCam()\n\nsynth.src(synth.s0)\n\t.blend(src(synth.s1))\n\t.modulateScale(synth.src(synth.o0).scale(1.01), [0,2].fast(0.1).smooth())\n\t//.thresh([.2,.7].smooth())\n\t//.modulate(noize(3,2),0.02)\n\t//.brightness(.2)\n\t//.contrast(3)\n\t.out()\n"},{"name":"testMIDI","code":"// register WebMIDI\nnavigator.requestMIDIAccess()\n    .then(onMIDISuccess, onMIDIFailure);\n\nfunction onMIDISuccess(midiAccess) {\n    console.log(midiAccess);\n    var inputs = midiAccess.inputs;\n    var outputs = midiAccess.outputs;\n    for (var input of midiAccess.inputs.values()){\n        input.onmidimessage = getMIDIMessage;\n    }\n}\n\nfunction onMIDIFailure() {\n    console.log('Could not access your MIDI devices.');\n}\n\n//create an array to hold our cc values and init to a normalized value\nvar cc=Array(128).fill(0.5)\n\ngetMIDIMessage = function(midiMessage) {\n    var arr = midiMessage.data    \n    var index = arr[1]\n    //console.log('Midi received on cc#' + index + ' value:' + arr[2])    // uncomment to monitor incoming Midi\n    var val = (arr[2]+1)/128.0  // normalize CC values to 0.0 - 1.0\n    cc[index]=val\n}\n\n// code hydra [+/-] p5 or drag + drop .js hydra/p5 file(s) here\n// code hydra [+/-] p5 or drag + drop .js hydra/p5 file(s) here\n//spheregrid1\nH.toggle(0) // hide hydra\nH.pd(.5)\n\nfunction grad1() {\n //return [.2,.999].smooth()\n return 3\n}\n\n\n//noize(30, 2).thresh(()=>sin(time)).mult(osc(40, 1, [.5,2].smooth()).colorama(.1).modulate(noize())).out()\n//noize(3, 2).modulate(noize(), window.grad1()).out()\n\ns0.initVideo(\"https://media.giphy.com/media/AS9LIFttYzkc0/giphy.mp4\")\ns1.initCam()\n//src(s1).modulate(noize(3), ()=>cc[56]).out()\nsolid(()=>cc[56]).out()\n\n\nspeed=10\n\nfunction setup() {\n createCanvas(windowWidth, windowHeight, WEBGL)\n P5.zIndex(1)\n normalMaterial()\n}\n\n\n\nfunction sphereSize(factor=1, speed=1){\n //return height/3+(frameCount%(height/6))\n return (Math.sin(frameCount*(speed/100))*100 +200)*factor\n}\n\nfunction sphereGrid(sphereSize=100, gridX=5, gridY=5, gridZ=5, spacing=200){\n  let offset = (gridX - 1) * spacing / 2\n  for (let x = 0; x < gridX; x++) {\n    for (let y = 0; y < gridY; y++) {\n      for (let z = 0; z < gridZ; z++) {\n        push();\n        // Positionner chaque sphère\n        translate(\n          x * spacing - offset,\n          y * spacing - offset,\n          z * spacing - offset\n        );\n        // Couleur basée sur la position\n/*        let r = map(x, 0, gridX - 1, 50, 255)\n        let g = map(y, 0, gridY - 1, 50, 255)\n        let b = map(z, 0, gridZ - 1, 50, 255)\n        fill(r, g, b)*/\n        texture(H.get())\n        sphere(sphereSize, 32)\n        pop()\n      }\n    }\n  }\n}\n\nfunction draw() {\n clear()\n background(0,70,90)\n orbitControl(0)\n rotateY(radians(frameCount/1))\n\n noStroke()\n texture(H.get())\n \n //sphere(sphereSize(), 64)\n sphereGrid(sphereSize(.5, 3), 3, 3, 3, spacing=400)\n}\n\n\nvar H2 = HY5.hydra('h2', 'synth')\nH2.pixelDensity(2)\nH2.zIndex(2)\nsynth.s0.initP5()\n\n/*synth.src(synth.s0)\n\t.blend(voronoi())\n\t//.modulateScale(synth.src(synth.o0).scale(1.01), [0,2].fast(0.1).smooth())\n\t//.thresh([.2,.7].smooth())\n\t//.modulate(noize(3,2),0.02)\n\t.brightness(.2)\n\t.contrast(3)\n\t.out()*/\n"},{"name":"sphereGridVideoHydraThresh","code":"// code hydra [+/-] p5 or drag + drop .js hydra/p5 file(s) here\n// code hydra [+/-] p5 or drag + drop .js hydra/p5 file(s) here\n//spheregrid1\nH.toggle(0) // hide hydra\nH.pd(.5)\n\nfunction grad1() {\n //return [.2,.999].smooth()\n return 3\n}\n\n\n//noize(30, 2).thresh(()=>sin(time)).mult(osc(40, 1, [.5,2].smooth()).colorama(.1).modulate(noize())).out()\n//noize(3, 2).modulate(noize(), window.grad1()).out()\n\ns0.initVideo(\"https://media.giphy.com/media/AS9LIFttYzkc0/giphy.mp4\")\nsrc(s0).modulate(noize(3)).out()\n\nspeed=10\n\nfunction setup() {\n createCanvas(windowWidth, windowHeight, WEBGL)\n P5.zIndex(1)\n normalMaterial()\n}\n\nfunction sphereSize(factor=1, speed=1){\n //return height/3+(frameCount%(height/6))\n return (Math.sin(frameCount*(speed/100))*100 +200)*factor\n}\n\nfunction sphereGrid(sphereSize=100, gridX=5, gridY=5, gridZ=5, spacing=200){\n  let offset = (gridX - 1) * spacing / 2\n  for (let x = 0; x < gridX; x++) {\n    for (let y = 0; y < gridY; y++) {\n      for (let z = 0; z < gridZ; z++) {\n        push();\n        // Positionner chaque sphère\n        translate(\n          x * spacing - offset,\n          y * spacing - offset,\n          z * spacing - offset\n        );\n        // Couleur basée sur la position\n/*        let r = map(x, 0, gridX - 1, 50, 255)\n        let g = map(y, 0, gridY - 1, 50, 255)\n        let b = map(z, 0, gridZ - 1, 50, 255)\n        fill(r, g, b)*/\n        texture(H.get())\n        sphere(sphereSize, 32)\n        pop()\n      }\n    }\n  }\n}\n\nfunction draw() {\n clear()\n background(0,70,90)\n orbitControl(0)\n rotateY(radians(frameCount/1))\n\n noStroke()\n texture(H.get())\n \n //sphere(sphereSize(), 64)\n sphereGrid(sphereSize(.5, 3), 3, 3, 3, spacing=400)\n}\n\n\nvar H2 = HY5.hydra('h2', 'synth')\nH2.pixelDensity(2)\nH2.zIndex(2)\nsynth.s0.initP5()\nH2.speed=10\nsynth.src(synth.s0)\n\t//.modulateScale(synth.src(synth.o0).scale(1.01), [0,2].fast(0.1).smooth())\n\t.thresh([.2,.7].smooth())\n\t.modulate(noize(3,2),0.02)\n\t.out()\n"},{"name":"sphereGridVideoFBglitch","code":"// code hydra [+/-] p5 or drag + drop .js hydra/p5 file(s) here\n// code hydra [+/-] p5 or drag + drop .js hydra/p5 file(s) here\n//spheregrid1\nH.toggle(0) // hide hydra\nH.pd(.5)\n\nfunction grad1() {\n //return [.2,.999].smooth()\n return 3\n}\n\n\n//noize(30, 2).thresh(()=>sin(time)).mult(osc(40, 1, [.5,2].smooth()).colorama(.1).modulate(noize())).out()\n//noize(3, 2).modulate(noize(), window.grad1()).out()\n\ns0.initVideo(\"https://media.giphy.com/media/AS9LIFttYzkc0/giphy.mp4\")\nsrc(s0).modulate(noize(3)).out()\n\nspeed=30\n\nfunction setup() {\n createCanvas(windowWidth, windowHeight, WEBGL)\n P5.zIndex(1)\n normalMaterial()\n}\n\nfunction sphereSize(factor=1, speed=1){\n //return height/3+(frameCount%(height/6))\n return (Math.sin(frameCount*(speed/100))*100 +200)*factor\n}\n\nfunction sphereGrid(sphereSize=100, gridX=5, gridY=5, gridZ=5, spacing=200){\n  let offset = (gridX - 1) * spacing / 2\n  for (let x = 0; x < gridX; x++) {\n    for (let y = 0; y < gridY; y++) {\n      for (let z = 0; z < gridZ; z++) {\n        push();\n        // Positionner chaque sphère\n        translate(\n          x * spacing - offset,\n          y * spacing - offset,\n          z * spacing - offset\n        );\n        // Couleur basée sur la position\n/*        let r = map(x, 0, gridX - 1, 50, 255)\n        let g = map(y, 0, gridY - 1, 50, 255)\n        let b = map(z, 0, gridZ - 1, 50, 255)\n        fill(r, g, b)*/\n        texture(H.get())\n        sphere(sphereSize, 32)\n        pop()\n      }\n    }\n  }\n}\n\nfunction draw() {\n clear()\n background(0)\n orbitControl(0)\n rotateY(radians(frameCount/1))\n\n noStroke()\n texture(H.get())\n \n //sphere(sphereSize(), 64)\n sphereGrid(sphereSize(.5, 3), 3, 3, 3, spacing=400)\n}\n\n\nvar H2 = HY5.hydra('h2', 'synth')\nH2.pixelDensity(2)\nH2.zIndex(2)\nsynth.s0.initP5()\nsynth.src(synth.s0)\n\t.modulateScale(synth.src(synth.o0).scale(1.01), .5)\n\t.out()"},{"name":"sphereGridVideo","code":"// code hydra [+/-] p5 or drag + drop .js hydra/p5 file(s) here\n// code hydra [+/-] p5 or drag + drop .js hydra/p5 file(s) here\n//spheregrid1\nH.toggle(0) // hide hydra\nH.pd(.5)\n\nfunction grad1() {\n //return [.2,.999].smooth()\n return 3\n}\n\n\n//noize(30, 2).thresh(()=>sin(time)).mult(osc(40, 1, [.5,2].smooth()).colorama(.1).modulate(noize())).out()\n//noize(3, 2).modulate(noize(), window.grad1()).out()\n\ns0.initVideo(\"https://media.giphy.com/media/AS9LIFttYzkc0/giphy.mp4\")\nsrc(s0).modulate(noize(3)).out()\n\nspeed=30\n\nfunction setup() {\n createCanvas(windowWidth, windowHeight, WEBGL)\n P5.zIndex(1)\n normalMaterial()\n}\n\nfunction sphereSize(factor=1, speed=1){\n //return height/3+(frameCount%(height/6))\n return (Math.sin(frameCount*(speed/100))*100 +200)*factor\n}\n\nfunction sphereGrid(sphereSize=100, gridX=5, gridY=5, gridZ=5, spacing=200){\n  let offset = (gridX - 1) * spacing / 2\n  for (let x = 0; x < gridX; x++) {\n    for (let y = 0; y < gridY; y++) {\n      for (let z = 0; z < gridZ; z++) {\n        push();\n        // Positionner chaque sphère\n        translate(\n          x * spacing - offset,\n          y * spacing - offset,\n          z * spacing - offset\n        );\n        // Couleur basée sur la position\n/*        let r = map(x, 0, gridX - 1, 50, 255)\n        let g = map(y, 0, gridY - 1, 50, 255)\n        let b = map(z, 0, gridZ - 1, 50, 255)\n        fill(r, g, b)*/\n        texture(H.get())\n        sphere(sphereSize, 32)\n        pop()\n      }\n    }\n  }\n}\n\nfunction draw() {\n clear()\n background(0)\n orbitControl(0)\n rotateY(radians(frameCount/1))\n\n noStroke()\n texture(H.get())\n \n //sphere(sphereSize(), 64)\n sphereGrid(sphereSize(.5, 3), 3, 3, 3, spacing=400)\n}"}]}